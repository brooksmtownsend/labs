<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Critical Stack Labs</title>
    <link>https://criticalstack.github.io/labs/</link>
    <description>Recent content on Critical Stack Labs</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 23 Apr 2019 09:43:37 -0400</lastBuildDate>
    
	<atom:link href="https://criticalstack.github.io/labs/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Deploying a Stateless Golang App</title>
      <link>https://criticalstack.github.io/labs/featurelabs/go/hello/</link>
      <pubDate>Tue, 23 Apr 2019 09:43:37 -0400</pubDate>
      
      <guid>https://criticalstack.github.io/labs/featurelabs/go/hello/</guid>
      <description>Deploying a Stateless Golang App in Critical Stack Getting Started Pre-requisites:
 Go Visual Studio Code curl or some equivalent way to do GET and POST If using curl, python to make JSON prettier Docker : Docker Public container registry Docker Hub A Critical Stack deployment with a user account provisioned for you. Note your namespace when you login.  Overview In this lab, you will deploy a simple Go Hello World application in Critical Stack and create Services to make it available externally.</description>
    </item>
    
    <item>
      <title>Deploying a Stateless Golang App with REST API</title>
      <link>https://criticalstack.github.io/labs/featurelabs/go/hello&#43;rest/readme/</link>
      <pubDate>Tue, 23 Apr 2019 09:43:37 -0400</pubDate>
      
      <guid>https://criticalstack.github.io/labs/featurelabs/go/hello&#43;rest/readme/</guid>
      <description>Deploying a Stateless Golang App with REST API in Critical Stack Getting Started Pre-requisites:
 Go Visual Studio Code curl or some equivalent way to do GET and POST If using curl, python to make JSON prettier Docker : Docker Public container registry Docker Hub Previous Go lab for Docker registry and Load Balancer setup - this demo will just update the previous Docker image with new functionality  Overview Update previous lab to introduce a REST API.</description>
    </item>
    
    <item>
      <title>Deploying a Stateless NodeJS App</title>
      <link>https://criticalstack.github.io/labs/featurelabs/node/deploystateless/</link>
      <pubDate>Tue, 23 Apr 2019 09:43:37 -0400</pubDate>
      
      <guid>https://criticalstack.github.io/labs/featurelabs/node/deploystateless/</guid>
      <description>Deploying a Stateless NodeJS App in Critical Stack Getting Started Pre-requisites:
 Node JS (and npm) : Node.JS Docker : Docker Public container registry (Docker Hub is easiest, Artifactory works too) : Docker Hub  Overview In this lab we will create a simple NodeJS application, deploy it via Critical Stack. and access it via a public URL.
Steps Building  Open a terminal window. In your current working directory (we use the Development directory under the user&amp;rsquo;s home directory in this example), create a lab directory called node-lab and a subdirectory of that called app:</description>
    </item>
    
    <item>
      <title>Updating a NodeJS App</title>
      <link>https://criticalstack.github.io/labs/featurelabs/node/updating/</link>
      <pubDate>Tue, 23 Apr 2019 09:43:37 -0400</pubDate>
      
      <guid>https://criticalstack.github.io/labs/featurelabs/node/updating/</guid>
      <description>Using Critical Stack to easily update a scalable, stateless application Getting Started Pre-requisites: Previous Node lab
Overview In the previous lab we created a simple NodeJS application, packaged the application in a Docker image, pushed the Docker image to a public Docker Hub repository, pulled that Docker image into a Critical Stack deployment as a container instance, and accessed the application via a public URL.
Now we will create more instances of the container, update the application to show bread crumbs of those instances, push that update to Docker Hub, and use the Critical Stack UI to instruct K8s to roll out the update while we refresh on the public URL to see the change deploy seamlessly.</description>
    </item>
    
  </channel>
</rss>